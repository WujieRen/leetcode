package com.rwj.ltc.recursion;

/**
 * @author rwj
 * @create_time 2021/8/1
 * @description 给定值n；求1+2+...n-1 + n的值
 *      1. 递归是一个较难理解的地方。递归需要满足的三个条件：
 *          1. 该问题可以拆分为多个求解思路相同的子问题（即有递归公式/规律存在）；
 *          2.存在终止递归的条件；
 *      2. 这也是求解递归问题的关键点。即：
 *          1. 写出递归公式；
 *          2. 找到终止递归的条件。
 *      3. 但是递归也存在一些严重的问题：
 *          1. 堆栈溢出：
 *              因为函数调用会用栈保存临时变量，
 *              每调用一个函数都会将临时变量封装为栈压入内存栈，等函数返回结果时才出栈。
 *              而系统或虚拟机栈空间一般都不是很大；
 *              如果递归求解的数据规模很大、调用层次很深，一直压栈就可能导致堆栈溢出。
 *          2.重复计算：
 *              比如： f(n) = f(n-1) + f(n-2)。f(5) = f(3) + f(4) = f(3) + f(3) + f(2)；这是就计算两次f(3)；
 *              如果层级更深；需要重复计算的就越多。
 *      4. 如果解决？
 *          1. 堆栈溢出
 *              - 通过在代码中限制递归调用的最大深度的方式。
 *                但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。
 *                如果实时计算，代码过于复杂，就会影响代码的可读性。
 *                所以，如果最大深度比较小，比如 10、50，就可以用这种方法，否则这种方法并不是很实用。
 *          2. 重复计算
 *              - 为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。
 *                当递归调用到 f(k) 时，先看下是否已经求解过了。
 *          3. 用非递归代码写。（根据场景决定）
 *
 */
public class Test {
    public static void main(String[] args) {

        // TODO:递归
        System.out.println(recursion(10));

        //非递归写法
        System.out.println(f(10));
    }

    // 递归写法
    private static int recursion(int n) {
        if(n == 1) return 1;
        /*int res = recursion(n - 1) + n;
        return res;*/
        return recursion(n - 1) + n;
    }

    //非递归写法
    private static int f(int n) {
        int ret = 1;
        for(int i = 2; i <= n; ++i) {
            ret = ret + i;
        }
        return ret;
    }



}
